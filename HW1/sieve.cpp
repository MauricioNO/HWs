// ITP 365 Spring 2015
// HW1 â€“ Sieve of Eratosthenes
// Name: Mauricio Nunes de Oliveira
// Email: nunesdeo@usc.edu
// Platform: Windows

#include "gwindow.h"
#include "sieve.h"


using std::cout;
using std::to_string;

const int height = 50;
const int width = 50;

void drawSquare(GWindow& gw, int label, NumberType type, double x, double y)
{
	switch (type)
	{
		case UNKOWN:
			gw.setColor("white");
			break;
		case PRIME:
			gw.setColor("green");
			break;
		case COMPOSITE:
			gw.setColor("red"); 
			break;
	}
	gw.fillRect(x, y, width, height);
	gw.setColor("black");
	gw.drawRect(x, y, width, height);
	gw.drawLabel(to_string(label), x+25, y+25);
	gw.setColor("black");
}

void initVectors(Vector<int>& label, Vector<NumberType>& type)
{
	for (int n = 2; n < 102; n++)
	{
		label.add(n);
		type.add(UNKOWN);
	}
}

void drawGrid(GWindow& gw, Vector<int>& label, Vector<NumberType>& type)
{
	double x = 0;
	double y = 0;
	for (int index = 0; index < 100; index++)
	{
		drawSquare(gw, label.get(index), type.get(index), x, y);
		if (x >= 450)
		{
			x = 0;
			y += 50;
		}
		else
		{
			x += 50;
		}		
	}
}

int calcNextPrime(Vector<int>& label, Vector<NumberType>& type, int startAt)
{
	int sum = startAt;
	//The following section executes while either the type is different than UNKOWN
	//Or the start point is equal 99(which means there are no more UNKOWNS)
	while ( !((type.get(startAt) == UNKOWN) || (startAt == 99)) )
	{
		startAt += 1;
		sum = startAt;
	}

	if (startAt == 99)
	{
		type.set(startAt, PRIME);	//Sets the 101 as PRIME
		return -1;
	}
	else
	{
		//This section sets the found prime number as PRIME, and then sums it with itself until
		//the sum is smaller than 100 in order to find all the composites generated by that prime
		type.set(startAt, PRIME);
		sum += label.get(startAt);
		while (sum < 100)
		{
			type.set(sum, COMPOSITE); 
			sum += label.get(startAt);
		} 
		return label.get(startAt); 
	}
}

